
<!-- TOC -->

- [排序算法介绍](#排序算法介绍)
  - [排序算法的分类](#排序算法的分类)
    - [内部排序:](#内部排序)
    - [外部排序法：](#外部排序法)
    - [常见的排序算法介绍](#常见的排序算法介绍)
  - [算法时间复杂度分析](#算法时间复杂度分析)
    - [度量一个程序(算法)执行时间的两种方法](#度量一个程序算法执行时间的两种方法)
    - [时间频度](#时间频度)
    - [时间复杂度](#时间复杂度)
    - [常见的时间复杂度](#常见的时间复杂度)
    - [平均时间复杂度和最坏时间复杂度](#平均时间复杂度和最坏时间复杂度)
  - [算法空间复杂度](#算法空间复杂度)

<!-- /TOC -->
## 排序算法介绍



排序也称排序算法(Sort Algorithm)，排序是将一组数据，依指定的顺序进行排列的过程。

### 排序算法的分类

#### 内部排序:

指将需要处理的所有数据都加载到内部存储器(内存)中进行排序。

#### 外部排序法： 

数据量过大，无法全部加载到内存中，需要借助外部存储(文件等)进行排序。

#### 常见的排序算法介绍

![1637926801729](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202111/26/194001-177555.png)

### 算法时间复杂度分析

#### 度量一个程序(算法)执行时间的两种方法

事后统计的方法：这种方法可行,  但是有两个问题：一是要想对设计的算法的运行性能进行评测，需要实际运行该程序；二是所 得时间的统计量依赖于计算机的硬件、软件等环境因素,  这种方式，要在同一台计算机的相同状态下运行，才能比较那个算法速度更快。

事前估算的方法：通过分析某个算法的时间复杂度来判断哪个算法更优。

#### 时间频度

一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。

#### 时间复杂度

一般情况下，算法中的基本操作语句的重复执行次数是问题规模 **n** 的某个函数，用 T(n)表示，若有某个辅
助函数 f(n)，使得当 n 趋近于无穷大时，T(n) / f(n)的极限值为不等于零的常数，则称f(n)是 T(n)的同数量级函数。 记作  **T(n)=**Ｏ**( f(n) )**，称Ｏ( f(n) )  为算法的渐进时间复杂度，简称时间复杂度。

 T(n) 不同，但时间复杂度可能相同。 如：T(n)=n²+7n+6  与 T(n)=3n²+2n+2  它们的 T(n) 不同，但时间复杂 度相同，都为 **O(n**²**)**。

#### 常见的时间复杂度

- 常数阶 O(1)

- 对数阶 O(log2n)

- 线性阶 O(n)

- 线性对数阶 O(nlog2n)

- 平方阶 O(n^2)

- 立方阶 O(n^3)

- k 次方阶 O(n^k)

- 指数阶 O(2^n)

- 阶乘阶 O(![img](file:///C:/Users/MrR/AppData/Local/Temp/msohtmlclip1/01/clip_image002.gif))

![1637926992929](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202111/26/194313-547181.png)

![1637927037142](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202111/26/194357-151074.png)

#### 平均时间复杂度和最坏时间复杂度

平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。

最坏情况下的时间复杂度称最坏时间复杂度。一般讨论的时间复杂度均是最坏情况下的时间复杂度。这样做的 原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间不会 比最坏情况更长。

平均时间s度和最坏时间复杂度是否一致，和算法有关(如图:)。

![1637927079272](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202111/26/194440-395079.png)

### 算法空间复杂度

类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)定义为该算法所耗费的存储空间，它也是问题规模 n 的函数。

空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的临时工作单元数与解决问题的规模 n 有关，它随着 n 的增大而增大，当 n 较大时，将占用较多的存储单元，例 如快速排序和归并排序算法**,** 基数排序就属于这种情况。

在做算法分析时，主要讨论的是时间复杂度。从用户使用体验上看，更看重的程序执行的速度。一些缓存产品(redis, memcache)和算法(基数排序)本质就是用空间换时间。