# 贪心算法

## 什么是贪心算法

贪心算法是指在每个阶段做选择的时候都做出当前阶段（或状态）最好的选择，并且期望这样做到的结
果是全局最优解（但未必是全局最优解）

贪心算法其实是动态规划的一种,由于它的「贪心」，只着眼于当前阶段的最优解，所以每个子问题只会
被计算一次，如果由此能得出全局最优解，相对于动态规划要对每个子问题求全局最优解，它的时间复
杂度无疑是会下降一个量级的。

举个简单的例子，⽐如给定某个数字的金额（如 250）与 100, 50, 10, 5, 1 这些纸币（不限量），怎么
能用最少张的纸币来兑换这张金额呢，显然每次兑换应该先从大额的纸币兑换起，第一次选 100， 第二
次还是选 100， 第三次选第二大的 50 元，每次都选小于剩余金额中的最大面额的纸币，这样得出的解
⼀定是全局最优解！时间复杂度无疑是线性的。

我们先来看几道可以用贪心算法来求解的例题

## 分糖果

> 有 m 个糖果和 n 个孩⼦子。我们现在要把糖果分给这些孩子吃，但是糖果少，孩子多（m < n），
> 所以糖果只能分配给⼀部分孩子。每个糖果的⼤小不等，这 m 个糖果的大小分别是s1，s2，s3，
> ……，sm。除此之外，每个孩子对糖果大小的需求也是不⼀样的，只有糖果的大小⼤于等于孩子
> 的对糖果大小的需求的时候，孩子才得到满足。假设这 n 个孩子对糖果大小的需求分别是 g1，
> g2，g3，……，gn。那么如何分配糖果，能尽可能满足最多数量的孩子呢?

求解：这道题如果用贪心来解题思路还是比较明显的，对于每个小孩的需求 gn，只要给他所有大小
大于 gn 的糖果中的最小值即可，这样就能把更大的糖果让给需求更大的小孩。整个代码如下：

~~~ java
public class Solution {
    /**
     * 获取能分配给⼩小孩且符合条件的最多糖果数
     */
    private static int dispatchCandy(int[] gList, int[] sList) {
        Arrays.sort(gList); // ⼩小孩对糖果的需求从⼩小到⼤大排列列
        Arrays.sort(sList); // 糖果⼤大⼩小从⼩小到⼤大排列列
        int maximumCandyNum = 0;
        for (int i = 0; i < gList.length; i++) {
            for (int j = 0; j < sList.length; j++) {
                // 选择最接近⼩小孩需求的糖果，以便便让更更⼤大的糖果满⾜足需求更更⼤大的⼩小孩
                if (gList[i] <= sList[j]) {
                    maximumCandyNum++;
                    // 糖果被选中，将其置为-1，代表⽆无效了了
                    sList[j] = -1;
                    // 糖果已选中，跳出
                    break;
                }
            }
        }
        return maximumCandyNum;
    }

    public static void main(String[] args) {
        // ⼩小孩对糖果的需求
        int[] gList = { 1, 2, 4, 6 };
        // 糖果实际⼤大⼩小
        int[] sList = { 1, 2, 7, 3 };
        int result = dispatchCandy(gList, sList);
        System.out.println("result = " + result);
    }
}
~~~

## 贪心算法使用场景

简单总结⼀下贪心算法，它指的是每⼀步只选最优的，并且期望每⼀步选择的最优解能达成全局的最优
解，说实话这太难了了，因为⼀般一个问题的选择都会影响下一个问题的选择，除非子问题之间完全独
立，没有关联，⽐如我们在文中开头说的凑零钱的例子， 如果一个国家的钞票⽐较奇葩，只有 1，5，
11 这三种⾯值的钞票，如何用最少的钞票凑出 15 呢，如果用贪⼼第一次选 11， 那之后只能选 4 张 1
了，即 15 = 1 x 11 + 4 x1。其实最优解应该是 3 张 5 元的钞票，为啥这种情况下用贪心不适⽤呢，因
为第一次选了 11，影响了后⾯钞票的选择，也就是说子问题之间并不是独立的，而是互相制约，互有
影响的，所以我们选贪心的时候一定要注意它的适用场景。

## 三角形最短路径和是否能用贪心算法求解

先回顾一下题目：

![1635209860466](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202110/26/085742-219066.png)

如图示，以上三角形由⼀连串的数字构成，要求从顶点 2 开始走到最底下边的最短路径，每次只能向当
前节点下面的两个节点走，如 3 可以向 6 或 5 走，不能直接走到 7。

![1635209920056](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202110/26/085841-667244.png)

底部的最短路径，它只关心节点 9， 10，之前层数的节点无需再关心！因为 9，10 已经是最优子结构
了，所以只保存每层节点（即⼀维数组）的最值即可！

如果使用贪心算法，求解步骤是这样的：

1. 第⼀步：由 2 往下走，由于 3 ⽐比 4 小，所以选择 3

![1635210009206](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202110/26/090010-103370.png)

2.  第二步：由 3 往下⾛，由于 5 ⽐ 6 小，所以选择 5

![1635210038052](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202110/26/090039-358731.png)

3. 第三步: 从 5 往下走， 1 比 8 小，选择 1

![1635210063882](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202110/26/090104-707061.png)

答案是 11 ，与动态规划得出的解一模一样！那是否说明这道题可以用贪心算法求解？

答案是否定的！上面的解之所以是正确的，是因为这些数字恰好按贪心求解出来得出了全局最优解，如
果我们换⼀下数字，看看会如何

![1635210104581](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202110/26/090145-756251.png)

如图示，如果数字换成如图中所示，则按贪心得出的最短路径是 66, ⽽而实际上最短路径应该为 16，如下
图所示：

![1635210143555](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202110/26/090224-135438.png)

为啥用贪心行不通呢，因为贪心追求的是每⼀步眼前的最优解，⼀旦它作出了选择，就会影响后面子问
题的选择，⽐如果选择了 3，就再也没法选择 7 了！所以再次强调，⼀定要注意贪心的适用场景，子
问题之间是否相互制约，相互影响！