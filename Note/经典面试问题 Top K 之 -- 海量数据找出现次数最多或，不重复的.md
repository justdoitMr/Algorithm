## 经典面试问题: Top K 之 -- 海量数据找出现次数最多或，不重复的

这些问题都是面临着有如下的考虑：

- 内存不足以放下所有的数。
- 机器CPU的核数不够。
- ...

### 一，找出不重复的

在`2.5亿`个`正整数`中找出不重复的整数。

#### 思路一：



#### `分治法 + HashMap` (HashMap 不要局限在 Java 语言)

将 2.5 亿个整数，分批操作，例如分成 250 万一批，共100批次。每批使用循环遍历一次，存入 `HashMap<int1,int2>` 里面，`int1` 对应这个数，`int2` 对应它出现的次数，没出现就默认是 1 次。每操作完一批，就进行当前的 `HashMap` 的`去重操作`，读出 `int2 > 1` 的，排除掉。接下来的批次，以此类推，得出 100，剩下的自然就是不重复的。

好了，我们现在来计算下上面这个方案的双间复杂度，`时间` & `空间`

`时间复杂度`：`250W * 100轮 + 其它批次`。对于多核机器，可以启动线程操作。

`空间复杂度`：使用 int 来进行存每一个数，保证不溢出情况下，那么就是 --> `Key + Value : (250W * 4字节，4Byte)/(1024*1024) ~ (Key + 9.5MB)` 内存。

#### **思路二：**

#### `位图法 Bitmap`(一个 bit 仅会是 0 或 1)

对于此题，我们可以设计每两个 `bit` 位，标示一个数的出现情况。`00`表示没有出现，`01`表示出现一次，`10`表示出现多次。2.5 亿个正整数，首先我们要知道是`正整数`，我们就不需要考虑负数，也就是无符号，`无符号的整形占四个字节`。

我们以这个为例子，开始计算`位图`内存。

1B = 8b，4B = 32b，它可以表示的`最大`的整数是 `2^32-1(不溢出)`，也就是说，我们需要 `2^32-1 ~ 2^32` 个`位`来表示这`2.5`亿个数。我们上面说了，`每个状态`是两个`位`，那么总共就是`2^32*2`个位。

那么我们可以一次申请的 位图 内存是：`2^32*2 bit ，(2^32*2)/(1024*1024*8) = 1GB` 即可。当然，我们也可以加上`分治`的思路，分批处理，不用直接用 1G，哈哈。

那么这样做的情况下怎样找到这个数呢？我举个例子，例如我们此时读入一个数是：`64`，`64`对应的所在`bit`位是：`64*2=128`，也就是说第 `127` 和 `128` 位共同`标示了它的出现状态`。其他的以此类推。每当我们读出一个数，我们就这样去找到它对应的`bit位`，先读出`bit位`的值，再做记录，已经是`01`的，再次来到，那么就应该修改为`10`。最后的我们这样得出结果：扫描整个位图，如果是`10`的，就`下标/2`得出这个数。

### **二，找出出现次数最多的**

第一题：找出一篇文章中，出现次数最多的单词。

第二题：10亿个`正整数`找出重复次数最多的100个整数。

#### **思路一：**

#### `分治法 + HashMap`

没错，`分治法 + HashMap` 这个方法就是可以用来处理很多 `Top K`问题的。

对于`问题一`，其实比较简单，这道题也是我 `2016 年腾讯第三轮技术面要求当场写代码的题目`。我们可以先判断，这篇文章可能很长，也可能很短，那么我们应该`规定一个字数的标志`，作为一批的字数限制，例如`100`个文字。每`100`个文字是一批的处理极限，我们先读出`100`个，100以内的就直接全部读出。读出后，打散成字符串，例如英语文章它以空格和一些符号分割。使用`split`方法就可以打散。此时我们得出一个字符串数组`String[] array`，有了这个之后就可以参考 `找出不重复` 问题的解法。每批使用循环遍历一次，存入 `HashMap<String,Integer>` 里面，`string` 对应这个数的字符串，`Integer` 对应它出现的次数，最后最大的自然就是出现次数最多的。下面直接给出个 `Demo 函数`。

![图片](https://mmbiz.qpic.cn/mmbiz_png/J5qtMtfPAwuXg6QqyTr9Dr5NAjWLiaPB6GoExoFeFbJADmvlbdPjPa0rmEzn3XxrQfsViajP80U6lVnFTSoNKJ5g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

第二题对应的 `分治法 + HashMap`

按照前面的案例，我们首先一样是要把这`十亿`个数分成很多份。例如 `1000份`，每份 `10万`。然后使用 `HashMap<int,int>` 来统计。在每一次的统计中，我们可以找出`最大的100个数`，为什么只找`10万`中的100个啊？因为我们有`1000份`，其它份里面的第二大可能是这份里最小的。这样全部加起来都`100*1000个`数了。OK，在我们找出这`100*1000`个侯选数后，继续分治处理，或者直接进行排序，如果直接排序就是`10W个数`。排序算法可以选`快排`等之类的，前`100个`就是结果。

#### **思路二：**

#### `位图法 Bitmap`

第一题，略。不是纯数字的，不建议采用`位图法`。

第二题：

有了 `找出不重复的` 的例子做基础。我们此时直接知道这题的 `正整数` 最大也是只能到 `2^23-1`，对于这道题，我们不需要`乘2`，所以我们申请的内存大小也是`512MB`。这样我们就能使用这个`位图`把所有数都存进去。如果出现了一次，该`bit位 = 1`，没有就是0。多次出现的话，我们就不能累加到`bit位`里面了，因为它最大就是`1`。这时候我们会发现，出现多次的话，是无法通过`bit位`进行累加记录的。所以，此题也是不适合采用`位图法`。

## **其他的**

例如问：`XXXXX中找出最大的一个，最小的一个，最大的几个，最小的几个`。这类的就可以使用`分治法+最小堆/最大堆`秒之。