## 剑指 Offer 14- I. 剪绳子

### [剑指 Offer 14- I. 剪绳子](https://leetcode-cn.com/problems/jian-sheng-zi-lcof/)

### 动态规划

首先让我们回顾一下动态规划三要素：

- 最有子结构
- 重叠子问题
- 状态转移方程

> 最优子结构是说我们的问题首先是求一个最值问题，那么这个最值问题，可以分解为多个小的子问题的最值问题，也就是说多个子问题的最值问题可以合并为大问题的最值问题。
>
> 重叠子问题：这个很好理解，在求解子问题的过程中，可能一个子问题被我们反反复复求了很多次，那么这个时候，为了加快计算，我们可以使用备忘录，记录已经计算出来子问题的解，下一次直接使用即可。
>
> 状态转移方程：这个是动态规划问题的核心，具体的我们如何从一个小问题推出大问题的解，这个过程用数学形式表达出来就是我们的状态转移方程。

好了，回顾完动态规划基础概念，我们来具体看看对应到这个问题上面如何思考：

#### 最优子结构

题目大意是给我们一段长度为n的绳子，让我们剪为m段，然后这m段绳子的乘积为最大，很好理解。

很明显，一看到求最值问题，那么首先表明本题可能用到动态规划我呢提，但是动态规划问题需要满足最优子结构，如果不满足最优子结构，即使求最值，也不能使用动态规划。

那么我们可以这样思考，我们要求分成M段绳子乘积的最大值，加入分成2段，a和b，此时a+b=m，那么是不是让我们分别求将第一段a分成m段乘积的最大值和第二段b分成m段乘积的最大值，这样想，那么是不是求绳子长度为a和b时候的最大值么，看看，题目让我们求绳子长度为m时候的最值，经过我们一番操作，转换为求绳子长度为a和b时候的最值，那么对于绳子长度为a，b我们可以继续求他的子问题的最值，这不就是最优子结构么？

通过子问题的最值可以计算总问题的最值。

这种方法是自顶向下，但是会有很多的重复子问题，这就谈到我们第二个问题：重叠子问题：

#### 重叠子问题

上面说到，如果采用自顶向下的计算方法，会产生很多子问题，具体来说，假如绳子长度是10，被我们分成5，5两端，那么我们需要分别计算长度为5时候最值，计算了两次，所以就叫做重复计算，所以我们可以采用备忘录，把计算过的值存放起来，下次计算直接拿来使用即可。

#### 状态转移方程

这个可以说是动态规划最重要的问题了，就那这个问题来讲，因为题目中说分的段数范围是`2—n`，当然分为n段没有意义，所以我们计算的时候默认认为是n-1段。

在本题目中，我们使用的是自底向上的计算方法：

- 首先定义状态数组status[n+1],当绳子长度是n的时候，最优的剪法乘积是status[n]，状态数组的含义一定要记清楚。
- 当绳子长度是2的时候，只有一种剪发，1，1,所以我们初始化状态数组status[2]=1。表示当绳子长度是2的时候，最优的剪法乘积是1.
- 当绳子长度是n的话，有n-1中剪的方法，那么假如是从i位置剪开，那么此时`status[n]=Math.max(status[i]，Math.max(status[i](n-i),(n-i）*n))`,这个式子表达什么含义呢，对于长度式n的绳子，我们从位置i处剪开，那么此时最优解式：绳子长度为i时候的最优值*剩下绳子的长度，和











这题用动态规划是比较好理解的

我们想要求长度为n的绳子剪掉后的最大乘积，可以从前面比n小的绳子转移而来
用一个dp数组记录从0到n长度的绳子剪掉后的最大乘积，也就是dp[i]表示长度为i的绳子剪成m段后的最大乘积，初始化dp[2] = 1
我们先把绳子剪掉第一段（长度为j），如果只剪掉长度为1，对最后的乘积无任何增益，所以从长度为2开始剪
剪了第一段后，剩下(i - j)长度可以剪也可以不剪。如果不剪的话长度乘积即为j * (i - j)；如果剪的话长度乘积即为j * dp[i - j]。取两者最大值max(j * (i - j), j * dp[i - j])
第一段长度j可以取的区间为[2,i)，对所有j不同的情况取最大值，因此最终dp[i]的转移方程为
dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]))
最后返回dp[n]即可

作者：edelweisskoko
链接：https://leetcode-cn.com/problems/jian-sheng-zi-lcof/solution/jian-zhi-offer-14-i-jian-sheng-zi-huan-s-xopj/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。