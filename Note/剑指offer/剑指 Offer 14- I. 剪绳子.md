## 剑指 Offer 14- I. 剪绳子

### [剑指 Offer 14- I. 剪绳子](https://leetcode-cn.com/problems/jian-sheng-zi-lcof/)

### 动态规划

首先让我们回顾一下动态规划三要素：

- 最有子结构
- 重叠子问题
- 状态转移方程

> 最优子结构是说我们的问题首先是求一个最值问题，那么这个最值问题，可以分解为多个小的子问题的最值问题，也就是说多个子问题的最值问题可以合并为大问题的最值问题。
>
> 重叠子问题：这个很好理解，在求解子问题的过程中，可能一个子问题被我们反反复复求了很多次，那么这个时候，为了加快计算，我们可以使用备忘录，记录已经计算出来子问题的解，下一次直接使用即可。
>
> 状态转移方程：这个是动态规划问题的核心，具体的我们如何从一个小问题推出大问题的解，这个过程用数学形式表达出来就是我们的状态转移方程。

好了，回顾完动态规划基础概念，我们来具体看看对应到这个问题上面如何思考：

#### 最优子结构

题目大意是给我们一段长度为n的绳子，让我们剪为m段，然后这m段绳子的乘积为最大，很好理解。

很明显，一看到求最值问题，那么首先表明本题可能用到动态规划我呢提，但是动态规划问题需要满足最优子结构，如果不满足最优子结构，即使求最值，也不能使用动态规划。

那么我们可以这样思考，我们要求分成M段绳子乘积的最大值，加入分成2段，a和b，此时a+b=m，那么是不是让我们分别求将第一段a分成m段乘积的最大值和第二段b分成m段乘积的最大值，这样想，那么是不是求绳子长度为a和b时候的最大值么，看看，题目让我们求绳子长度为m时候的最值，经过我们一番操作，转换为求绳子长度为a和b时候的最值，那么对于绳子长度为a，b我们可以继续求他的子问题的最值，这不就是最优子结构么？

通过子问题的最值可以计算总问题的最值。

这种方法是自顶向下，但是会有很多的重复子问题，这就谈到我们第二个问题：重叠子问题：

#### 重叠子问题

上面说到，如果采用自顶向下的计算方法，会产生很多子问题，具体来说，假如绳子长度是10，被我们分成5，5两端，那么我们需要分别计算长度为5时候最值，计算了两次，所以就叫做重复计算，所以我们可以采用备忘录，把计算过的值存放起来，下次计算直接拿来使用即可。

#### 状态转移方程

这个可以说是动态规划最重要的问题了，就那这个问题来讲，因为题目中说分的段数范围是`2—n`，当然分为n段没有意义，所以我们计算的时候默认认为是n-1段。

在本题目中，我们使用的是自底向上的计算方法：

- 首先定义状态数组status[n+1],当绳子长度是n的时候，最优的剪法乘积是status[n]，状态数组的含义一定要记清楚。
- 当绳子长度是2的时候，只有一种剪发，1，1,所以我们初始化状态数组status[2]=1。表示当绳子长度是2的时候，最优的剪法乘积是1.
- 当绳子长度是n的话，有n-1中剪的方法，那么假如是从i位置剪开，那么此时`status[n]=Math.max(status[i]，Math.max(status[i](n-i),(n-i）*i))`,这个式子表达什么含义呢，对于长度式n的绳子，我们从位置i处剪开，那么此时最优解式：绳子长度为i时候的最优值*剩下绳子的长度，和绳子长度为i时候，在乘以剩下的长度，这两者取最大值，这就是状态转移方程。

#### 完整过程

1. 我们想要求长度为n的绳子剪掉后的最大乘积，可以从前面比n小的绳子转移而来
2. 用一个dp数组记录从0到n长度的绳子剪掉后的最大乘积，也就是dp[i]表示长度为i的绳子剪成m段后的最大乘积，初始化dp[2] = 1
3. 我们先把绳子剪掉第一段（长度为j），如果只剪掉长度为1，对最后的乘积无任何增益，所以从长度为2开始剪
4. 剪了第一段后，剩下(i - j)长度可以剪也可以不剪。如果不剪的话长度乘积即为j * (i - j)；如果剪的话长度乘积即为j * dp[i - j]。取两者最大值max(j * (i - j), j * dp[i - j])
5. 第一段长度j可以取的区间为[2,i)，对所有j不同的情况取最大值，因此最终dp[i]的转移方程为
   dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]))
6. 最后返回dp[n]即可

#### 完整代码

~~~ java
class Solution {
    public int cuttingRope(int n) {
        //定义dp数组，dp[i]表示长度为i的绳子剪成m端后长度的最大乘积(m>1)
        int dp[] = new int[n+1];
        //初始化
        dp[2] = 1;
        //目标：求出dp[n]
        //dp[2]已知，从dp[3]开始求，直到求出dp[n]
        for(int i = 3;i <= n;i++){
            //首先对绳子剪长度为j的一段,其中取值范围为 2 <= j < i
            for(int j = 2;j < i;j++){
                
                //转移方程如下
                dp[i] = Math.max(dp[i],Math.max(j*(i-j),j*dp[i-j]));
                //Math.max(j*(i-j),j*dp[i-j]是由于减去第一段长度为j的绳子后，可以继续剪也可以不剪
                //Math.max(dp[i],Math.max(j*(i-j),j*dp[i-j]))是当j不同时，求出最大的dp[i]
            }
        }
        //现在已经求出每个长度i对应的最大乘积，返回dp[n]
        return dp[n];
    }
}
时间复杂度为O(n^2
~~~

### 贪心算法

- 当绳子长度为2时，只可能剪成长度为1的两段
- 当绳子长度为3时，可能把绳子剪成长度分别为1和2的两段或者长度都为1的三段，因为12>11*1
- 当绳子长度>=5时，尽可能多的剪长度为3的绳子，当剩下的绳子长度为4时，把绳子剪成长度为2的绳子

> 置于数学证明过程，可以参考往网上博客，这里不在证明。

#### 完整代码

~~~ java
var cuttingRope = function(n) {
  if (n < 2) return 0;
  // 当绳子长度为2时，只可能剪成长度为1的两段
  if (n === 2) return 1;
  // 当绳子长度为3时，可能把绳子剪成长度分别为1和2的两段或者长度都为1的三段，因为1*2>1*1*1
  if (n === 3) return 2;
  // a的含义：n能拆成的3的个数
  const a = Math.floor(n / 3);
  const b = n % 3;

  // n是3的倍数
  if (b === 0) return Math.pow(3, a);
  // n是 3k + 1，例如7。拆成3、3、1。由于有1对结果无法有贡献，所以最后的3、1换成4
  if (b === 1) return Math.pow(3, a - 1) * 4;
  return Math.pow(3, a) * 2;
};

~~~

### [剑指 Offer 14- II. 剪绳子 II](https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/)

步骤如下：

1. 如果 n == 2，返回1，如果 n == 3，返回2，两个可以合并成n小于4的时候返回n - 1
2. 如果 n == 4，返回4
3. 如果 n > 4，分成尽可能多的长度为3的小段，每次循环长度n减去3，乘积res乘以3；最后返回时乘以小于等于4的最后一小段；每次乘法操作后记得取余就行
4. 以上2和3可以合并

~~~java
class Solution {
    public int cuttingRope(int n) {
        if(n < 4){
            return n - 1;
        }
        long res = 1;
        while(n > 4){
            res  = res * 3 % 1000000007;
            n -= 3;
        }
        return (int) (res * n % 1000000007);
    }
}
~~~

![1650438697041](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202204/20/151137-814476.png)

