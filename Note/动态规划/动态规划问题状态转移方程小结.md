# 动态规划问题状态转移方程小结

## 跳台阶问题

> 定义d[i]数组为到第i个台阶位置，一共右多少种跳法。

假设当前在第n个位置，那么如果跳到第n个位置，一共有多少种跳法。

- 第一种是从n-1位置跳
- 第二种是从n-2位置跳

所以跳到第n个台阶共有两种方法，也就是`d[n]=d[n-1+d[n-2]`

> 所以状态转移方程是：`d[n]=d[n-1+d[n-2]`

## 机器人问题

> 定义`d[i][j]`为到第`[i,j]`位置时候，右多少条路径

假设机器人现在在d[i,j]位置，但是机器人每一次只可以向下或者向右走，所以走到`d[i][j]`位置也有两种方法：

- 从`d[i][j-1]`位置
- 从`d[i-1][j]`位置

> 所以找到的状态转移方程是：`d[i][j]=d[i][j-1]+d[i-1][j]`

## 对角和问题

> 定义`d[i][j]`为到第`[i,j]`位置时候，最短路径和是多少

因为是求最小值，那么假设现在在`d[i,j]`位置，但是机器人每一次只可以向下或者向右走，所以走到`d[i][j]`位置也有两种方法：

- 从`d[i][j-1]`位置
- 从`d[i-1][j]`位置

> 因为是求路径的最小值，所以我们取两个位置的最小值，可以得到状态转移方程是：
>
> `d[i][j]=min(d[i][j-1]+d[i-1][j])+dp[i][j]`

## 编辑距离

> **`dp[i][j]` 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为`dp[i][j]`**。

在确定递推公式的时候，首先要考虑清楚编辑的几种操作，整理如下：

```java
if (word1[i - 1] == word2[j - 1])
    不操作
if (word1[i - 1] != word2[j - 1])
    增
    删
    换
```

也就是如上4种情况。

`if (word1[i - 1] == word2[j - 1])` 那么说明不用任何编辑，`dp[i][j]` 就应该是 `dp[i - 1][j - 1]`，即`dp[i][j] = dp[i - 1][j - 1]`;

此时可能有同学有点不明白，为啥要即`dp[i][j] = dp[i - 1][j - 1]`呢？

那么就在回顾上面讲过的`dp[i][j]`的定义，`word1[i - 1]` 与 `word2[j - 1]`相等了，那么就不用编辑了，以下标i-2为结尾的字符串word1和以下标j-2为结尾的字符串`word2`的最近编辑距离`dp[i - 1][j - 1]`就是 `dp[i][j]`了。

在下面的讲解中，如果哪里看不懂，就回想一下`dp[i][j]`的定义，就明白了。

**在整个动规的过程中，最为关键就是正确理解`dp[i][j]`的定义！**

`if (word1[i - 1] != word2[j - 1])`，此时就需要编辑了，如何编辑呢？

- 操作一：word1删除一个元素，那么就是以下标i - 2为结尾的word1 与 j-1为结尾的word2的最近编辑距离 再加上一个操作。

即 `dp[i][j] = dp[i - 1][j] + 1;`

- 操作二：word2删除一个元素，那么就是以下标i - 1为结尾的word1 与 j-2为结尾的word2的最近编辑距离 再加上一个操作。

即 `dp[i][j] = dp[i][j - 1] + 1;`

这里有同学发现了，怎么都是删除元素，添加元素去哪了。

**word2添加一个元素，相当于word1删除一个元素**，例如 `word1 = "ad" ，word2 = "a"`，`word1`删除元素`'d'` 和 `word2`添加一个元素`'d'`，变成`word1="a", word2="ad"`， 最终的操作数是一样！

操作三：替换元素，`word1`替换`word1[i - 1]`，使其与`word2[j - 1]`相同，此时不用增加元素，那么以下标`i-2`为结尾的`word1` 与 `j-2`为结尾的`word2`的最近编辑距离 加上一个替换元素的操作。

即 `dp[i][j] = dp[i - 1][j - 1] + 1;`

综上，当 `if (word1[i - 1] != word2[j - 1])` 时取最小的，即：`dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;`

3. dp数组如何初始化

再回顾一下dp[i][j]的定义：

**`dp[i][j] `表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为`dp[i][j]`**。

那么`dp[i][0] `和 `dp[0][j] `表示什么呢？

`dp[i][0]` ：以下标i-1为结尾的字符串word1，和空字符串word2，最近编辑距离为`dp[i][0]`。

那么`dp[i][0]`就应该是i，对word1里的元素全部做删除操作，即：`dp[i][0] = i`;

同理`dp[0][j] = j`;

~~~java
        for(int i=1;i<=sz1;i++){
            for(int j=1;j<=sz2;j++){
                if(word1[i-1]==word2[j-1]){
                    dp[i][j]=dp[i-1][j-1];
                }else{
                    dp[i][j]=Math.min(dp[i-1][j]+1,dp[i][j-1]+1);
                    dp[i][j]=Math.min(dp[i][j],dp[i-1][j-1]+1);
                }
            }
        }
~~~

## [63. 不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)

> `dp[i][j]`表示跳到i,j位置一供有多少中跳法。

递推公式：`dp[i][j]=dp[i-1][j]+dp[i][j-1]`

有障碍物，只需要跳过障碍物即可。

## [343. 整数拆分](https://leetcode-cn.com/problems/integer-break/)

> dp[i]表示到i为止，数字i被拆分组成的最大的积
>
> dp[2]=1

第推公式：`dp[i] = max{dp[i],dp[i-j]*j,(i-j)*j}`

## [96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)

> **dp[i] ： 1到i为节点组成的二叉搜索树的个数为dp[i]**。
>
> dp[0]=1

递推公式：`dp[i] += dp[j - 1] * dp[i - j]`

~~~java
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= i; j++) {
        dp[i] += dp[j - 1] * dp[i - j];
    }
}
~~~

## 最大子序列和

> 以nums[i]为结尾的「最大子数组和」为dp[i]。

那么还是使用数学归纳法，假设我们现在知道`dp[i-1]`，那么我们如何知道`dp[i]`呢，显然，我们在这里右两种选择：

- 要么把num[i]和前面子序列和链接在一起组成一个更大的子序列和。
- 要么把num[i]单独放在一起开始计算一个新的子序列和.

> 根据归纳总结，我们可以得到状态转移方程：`dp[i]=max(dp[i-1]+num[i]，num[i])`

## 最长递增子序列

> 定义dp[i] 表示以 nums[i] 这个数结尾的最长递增子序列的长度

那么还是数学归纳法，假设现在`dp[0],dp[1]dp[2]…….dp[i-1]`我们都已经计算出来，那么此时我们如何通过`dp[i-1]`计算处`dp[i]`呢。很明显，这道题目是非连续的，所以我们只需要找到，在dp[i]之前的并且数组值小于num[i]的最大的那个dp对应的值，当然我们可能找到多个满足条件的结果，但是我们只取最大的，所以我们可以得到状态转移方程为：

> `dp[i]= Math.max(dp[i], dp[j] + 1)`，这里要注意一点，num[j] < num[i]时候才成立，j<i

## 最长连续递增子序列

> 还是先定义我们dp数组的含义：dp[i]：以下标i为结尾的数组的连续递增的子序列长度为dp[i]。

先假设我们的`dp[0],dp[1]dp[2]…….dp[i-1]`已经求出，那么如何取推导`dp[i]`的值呢？本题目求的是连续的子序列，所以求`dp[i]`也有两种情况：

- 要么把`num[i]`添加到前面的连续子序列当中，形成一个更大的子序列
- 要么把`num[i]`单独形成一个子序列

> 所以我们可以得到状态转移方程：`dp[i]=max(dp[i-1]+1，1)`