## 0-1背包问题

0-1背包问题重点理解状态转移方程：

- `j<weight[i]:dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])`
- `j>=weight[i]:dp[i][j]=Math.max(dp[i-1][j], dp[i-1][j-weight[i-1]]+value[i-1])`

**首先我们需要理解`dp[i][j]`数组的含义，表示从物品`0-i`中，当背包容量为j的时候，可以获取的最大价值。**

对于0-1背包问题，一件物品，我们只有两种选择，装入和不装入。

看一个例子：

![1639962545162](C:\Users\MrR\AppData\Roaming\Typora\typora-user-images\1639962545162.png)

现在weight={1,3,4},value={15,20,30},背包容量是4.

- 对于第一行，当背包容量为0的时候，不能装载物品1，背包容量依次增大，当背包容量为1，2，3，4的时候，已经可以装下物品一了，所以获取的价值是15.

- 再来看第二行，也就是判断第二个物品是否可以装入背包，当背包容量为0的时候，不能装下，所以获取价值为0
  - 当背包容量为1，此时可以看到，j<weight[i]，所以不能装入第二个物品，所以最大的价值还是装入第一个物品时候获得的价值。
  - 当背包容量变为3的时候，此时，j>=weight[i],说明可以装得下当前的物品，

**完整代码**

~~~ java
 /**
     * 
     * @param weight 物品重量
     * @param value 物品价值
     * @param packageSize 背包容量
     * @return
     */
    public int zeroOnePackage(int []weight,int []value,int packageSize){


//         声明dp数组
        int [][]dp = new int[weight.length+1][packageSize+1];

        // 初始化数组
        for(int i=0;i<=weight.length;i++){
            Arrays.fill(dp[i], 0);
        }

        for(int i=1;i<=weight.length;i++){
            for(int j=1;j<=packageSize;j++){
                if(j < weight[i-1]){
                    dp[i][j]=dp[i-1][j];
                }else{
                    dp[i][j]=Math.max(dp[i-1][j], dp[i-1][j-weight[i-1]]+value[i-1]);
                }
            }
        }
        for(int i=0;i<=weight.length;i++){
            for(int j=0;j<=packageSize;j++){
                System.out.print(dp[i][j]+" ");
            }
            System.out.println();
        }

        return dp[weight.length][packageSize];

    }
~~~

