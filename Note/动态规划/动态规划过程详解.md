# 动态规划

动态规划，无⾮就是利用历史记录，来避免我们的重复计算。而这些历史记录，我们得需要一些变量来
保存，⼀般是用一维数组或者二维数组来保存。下⾯面我们先来讲下做动态规划题很重要的三个步骤，

1. 第⼀步骤：定义数组元素的含义，上⾯面说了，我们会用一个数组，来保存历史数组，假设⽤一维数组dp[] 吧。这个时候有一个⾮常非常重要的点，就是规定你这个数组元素的含义，例如你的 dp[i] 是代表什么意思？
2. 第二步骤：找出数组元素之间的关系式，我觉得动态规划，还是有一点类似于我们高中学习时的归纳法的，当我们要计算 dp[n] 时，是可以利用 dp[n-1]，dp[n-2].....dp[1]，来推出 dp[n] 的，也就是可以利利用历史数据来推出新的元素值，所以我们要找出数组元素之间的关系式，例如 dp[n] = dp[n-1] + dp[n-2]，这个就是他们的关系式了。而这⼀步，也是最难的一步，后面我会讲几种类型的题来说。
3. 第三步骤：找出初始值。学过数学归纳法的都知道，虽然我们知道了数组元素之间的关系式，例如
   dp[n] = dp[n-1] + dp[n-2]，我们可以通过 dp[n-1] 和 dp[n-2] 来计算 dp[n]，但是，我们得知道初始值
   啊，例如一直推下去的话，会由 dp[3] = dp[2] + dp[1]。而 dp[2] 和 dp[1] 是不能再分解的了，所以我
   们必须要能够直接获得 dp[2] 和 dp[1] 的值，而这，就是所谓的初始值。有了初始值，并且有了数组元素之间的关系式，那么我们就可以得到 dp[n] 的值了了，而 dp[n] 的含义是由你来定义的，你想求什么，就定义它是什么，这样，这道题也就解出来了了。


## 案例讲解

### 案例一：简单的一维 DP

**问题描述**

> 问题描述：⼀只⻘蛙一次可以跳上1级台阶，也可以跳上2级。求该⻘蛙跳上⼀个n级的台阶总共有
> 多少种跳法。

1. 定义数组元素的含义

按我上面的步骤说的，首先我们来定义 dp[i] 的含义，我们的问题是要求⻘蛙跳上 n 级的台阶总共由多
少种跳法，那我们就定义 dp[i] 的含义为：**跳上一个 i 级的台阶总共有 dp[i] 种跳法**。这样，如果我们能
够算出 dp[n]，不就是我们要求的答案吗？所以第⼀步定义完成。

2. 找出数组元素间的关系式

我们的目的是要求 dp[n]，动态规划的题，如你们经常听说的那样，就是把一个规模比较大的问题分成
几个规模⽐较小的问题，然后由小的问题推导出大的问题。也就是说，dp[n] 的规模为 n，比它规模⼩
的是 n-1, n-2, n-3.... 也就是说，dp[n] ⼀定会和 dp[n-1], dp[n-2]....存在某种关系的。我们要找出他们的关系。

那么问题来了，怎么找？

这个怎么找，是最核⼼最难的一个，我们必须回到问题本身来了，来寻找他们的关系式，dp[n] 究竟会
等于什么呢？

对于这道题，由于情况可以选择跳一级，也可以选择跳两级，所以⻘蛙到达第 n 级的台阶有两种方式
一种是从第 n-1 级跳上来，一种是从第 n-2 级跳上来，由于我们是要算所有可能的跳法的，所以有 dp[n] = dp[n-1] + dp[n-2]。

3. 找出初始条件

当 n = 1 时，dp[1] = dp[0] + dp[-1]，而我们是数组是不允许下标为负数的，所以对于 dp[1]，我们必须
要直接给出它的数值，相当于初始值，显然，dp[1] = 1。一样，dp[0] = 0.（因为 0 个台阶，那肯定是
0 种跳法了了）。于是得出初始值：dp[0] = 0. dp[1] = 1. 即 n <= 1 时，dp[n] = n.

三个步骤都定义出来，接下来可以实现代码：

~~~ java
int f( int n ){
  if(n <= 1)
  	return n;
  // 先创建⼀一个数组来保存历史数据
  int[] dp = new int[n+1];
  // 给出初始值
  dp[0] = 0;
  dp[1] = 1;
  // 通过关系式来计算出 dp[n]
  for(int i = 2; i <= n; i++){
  	dp[i] = dp[i-1] + dp[i-2];
  }
  // 把最终结果返回
  return dp[n];
}
~~~

4. 再说初始化

⼤大家先想以下，你觉得，上⾯面的代码有没有问题？
答是有问题的，还是错的，错在对初始值的寻找不够严谨，这也是我故意这样弄的，意在告诉你们，关
于初始值的严谨性。例如对于上面的题，当 n = 2 时，dp[2] = dp[1] + dp[0] = 1。这显然是错误的，你
可以模拟一下，应该是 dp[2] = 2。

也就是说，在寻找初始值的时候，⼀定要注意不要找漏了了，dp[2] 也算是一个初始值，不能通过公式计
算得出。

**ACM模式代码**

~~~java
import java.util.*;

// 注意类名必须为 Main, 不要有任何 package xxx 信息
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        // 注意 hasNext 和 hasNextLine 的区别
         int n = in.nextInt();
        int dp[] = new int[n+1];
        dp[0]=1;
        dp[1]=1;
        for(int i=2;i<=n;i++){
            dp[i]=dp[i-1]+dp[i-2];
        }
        
        System.out.println(dp[n]);
    }
}
~~~

### 案例⼆：二维数组的 DP

**问题描述**

> ⼀个机器⼈位于一个 m x n ⽹格的左上角 （起始点在下图中标记为“Start” ）。机器⼈每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标为“Finish”）。问总共有多少条不同的路径？

![1635136417399](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202110/25/123338-550307.png)

下面还是按照动态规划三步走解决：

1. **步骤一、定义数组元素的含义**

由于我们的目的是从左上角到右下角⼀共有多少种路径，那我们就定义 dp[i] [j]的含义为：当机器人从
左上角走到(i, j) 这个位置时，⼀共有 dp[i] [j] 种路径。那么，dp[m-1] [n-1] 就是我们要的答案了了。

> 注意，这个网格相当于⼀个⼆维数组，数是从下标为 0 开始算起的，所以 右下角的位置是 (m-
> 1, n - 1)，所以 dp[m-1] [n-1] 就是我们要找的答案。

2. **步骤二：找出关系数组元素间的关系式**

想象以下，机器人要怎样才能到达 (i, j) 这个位置？由于机器⼈可以向下走或者向右走，所以有两种方
式到达，一种是从 (i-1, j) 这个位置走一步到达，一种是从(i, j - 1) 这个位置走一步到达，因为是计算所有可能的步骤，所以是把所有可能⾛的路径都加起来，所以关系式是 dp[i] [j] = dp[i-1] [j]+dp[i] [j-1]。

3. **步骤三、找出初始值**

显然，当 dp[i] [j] 中，如果 i 或者 j 有一个为 0，那么还能使用关系式吗？

答是不能的，因为这个时候把i - 1 或者 j - 1，就变成负数了，数组就会出问题了，所以我们的初始值是计算出所有的 dp[0] [0….n-1]和所有的 dp[0….m-1] [0]。这个还是非常容易计算的，相当于计算图中的最上面一行和左边一列。因此初始值如下：

- dp[0] [0….n-1] = 1; // 相当于最上面⼀行，机器⼈只能⼀直往左走
- dp[0…m-1] [0] = 1; // 相当于最左面⼀一列，机器⼈只能一直往下走

定义完成上面三步骤，下面实现代码：

~~~ java
class Solution {
    public int uniquePaths(int m, int n) {
        if(m <= 0 || n<= 0)
        return -1;

        // 使用动态规划方法
        // 1、定义状态数组
        int [][]status=new int[m][n];
        // 2、初始化边界条件,第一行和第一列全部初始化为1，因为只有一种走法
        for(int i=0;i<m;i++){
            status[i][0]=1;
        }
        for(int j=0;j<n;j++){
            status[0][j]=1;
        }
        // 3、定义状态方程
        // d[i][j]=d[i-1][j]+d[i][j-1]
        for(int i=1;i<m;i++){
            for(int j=1;j<n;j++){
                status[i][j]=status[i-1][j]+status[i][j-1];
            }
        }
        return status[m-1][n-1];
    }
}
~~~

> O(n*m) 的空间复杂度可以优化成 O(min(n, m)) 的空间复杂度的

### 案例三：二维数组 DP

**问题描述**

> 给定⼀个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。说明：每次只能向下或者向右移动⼀一步。

![1635137793441](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202110/25/125633-630155.png)

下面还是三步骤解决问题：

1. **步骤一、定义数组元素的含义**

由于我们的目的是从左上角到右下角，最小路径和是多少，那我们就定义 dp[i] [j]的含义为：当机器人
从左上角走到(i, j) 这个位置时，最下的路径和是 dp[i] [j]。那么，dp[m-1] [n-1] 就是我们要的答案了了。

> 注意，这个网格相当于一个⼆维数组，数组是从下标为 0 开始算起的，所以 由下角的位置是 (m-
> 1, n - 1)，所以 dp[m-1] [n-1] 就是我们要走的答案。

2. **步骤二：找出关系数组元素间的关系式**

想象以下，机器人要怎么样才能到达 (i, j) 这个位置？由于机器人可以向下走或者向右走，所以有两种方
式到达，一种是从 (i-1, j) 这个位置走一步到达，一种是从(i, j - 1) 这个位置走一步到达，不过这次不是计算所有可能路径，而是计算哪一个路径和是最小的，那么我们要从这两种方式中，选择一种，使得dp[i] [j] 的值是最小的，显然有：

~~~ java
dp[i] [j] = min(dp[i-1][j]，dp[i][j-1]) + arr[i][j];// arr[i][j] 表示⽹网格种的值
~~~

3. **步骤三、找出初始值**

显然，当 dp[i] [j] 中，如果 i 或者 j 有⼀个为 0，那么还能使用关系式吗？答是不能的，因为这个时候把
i - 1 或者 j - 1，就变成负数了，数组就会出问题了，所以我们的初始值是计算出所有的 dp[0] [0….n-1]
和所有的 dp[0….m-1] [0]。这个还是⾮常容易计算的，相当于计算机图中的最上面一行和左边一列。因
此初始值如下：

- dp[0] [j] = arr[0] [j] + dp[0] [j-1]; // 相当于最上⾯⼀行，机器人只能⼀直往左走
- dp[i] [0] = arr[i] [0] + dp[i] [0]; // 相当于最左面⼀列，机器⼈只能⼀直往下走

按照上面三个步骤，可以实现代码：

~~~ java
class Solution {
    public int minPathSum(int[][] grid) {

        // 1、定义动态规划状态数组
        int [][]status=new int[grid.length][grid[0].length];
        status[0][0]=grid[0][0];

        // 2、初始化边界值
        // 初始化行
        for(int i=1;i< grid.length;i++){
            status[i][0]=grid[i][0]+status[i-1][0];
        }
        // 初始化列
        for(int j=1;j< grid[0].length;j++){
            status[0][j] =grid[0][j]+status[0][j-1];
        }

        // 3、定义状态转移方程
        for(int i=1;i<grid.length;i++){
            for(int j=1;j<grid[0].length;j++){
                status[i][j]=Math.min(grid[i][j]+status[i][j-1], grid[i][j]+status[i-1][j]);
            }
        }
        return status[grid.length-1][grid[0].length-1];
    }
}
~~~

> O(n*m) 的空间复杂度可以优化成 O(min(n, m)) 的空间复杂度的

### 案例例 四：编辑距离(二维数组DP)

**题目描述**

> 给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使⽤的最少操作数 。
>
> 你可以对⼀个单词进⾏行行如下三种操作：
>
> - 插入一个字符 
> - 删除⼀个字符 
> - 替换一个字符

![1635140013430](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202110/25/133334-844670.png)

1. 步骤⼀、定义数组元素的含义

由于我们的目的求将 word1 转换成 word2 所使用的最少操作数 。那我们就定义 dp[i] [j]的含义为：当
字符串 word1 的长度为 i，字符串 word2 的长度为 j 时，将 word1 转化为 word2 所使⽤的最少操作
次数为 dp[i] [j]。

> 定义数组的含义，多数情况下是根据我们个人的经验

2. 步骤二：找出关系数组元素间的关系式

接下来我们就要找 dp[i] [j] 元素之间的关系了，⽐起其他题，这道题相对⽐较难找⼀点，但是，不管多难找，大部分情况下，dp[i] [j] 和 dp[i-1] [j]、dp[i] [j-1]、dp[i-1] [j-1] 肯定存在某种关系。因为我们的目标就是，从规模小的，通过一些操作，推导出规模大的。对于这道题，我们可以对 word1 进行三种操作：插入⼀个字符，删除⼀个字符，替换一个字符。

由于我们是要让操作的次数最小，所以我们要寻找最佳操作。那么有如下关系式：

- 如果我们 word1[i] 与 word2 [j] 相等，这个时候不需要进行任何操作，显然有 dp[i] [j] = dp[i-1] [j-
  1]。（别忘了了 dp[i] [j] 的含义哈）。
- 如果我们 word1[i] 与 word2 [j] 不相等，这个时候我们就必须进行调整，而调整的操作有 3 种，我
  们要选择一种。三种操作对应的关系试如下（注意字符串与字符的区别）
  - 如果把字符 word1[i] 替换成与 word2[j] 相等，则有 dp[i] [j] = dp[i-1] [j-1] + 1;
  - 如果在字符串串 word1末尾插入一个与 word2[j] 相等的字符，则有 dp[i] [j] = dp[i] [j-1] + 1;
  - 如果把字符 word1[i] 删除，则有 dp[i] [j] = dp[i-1] [j] + 1;

那么我们应该选择一种操作，使得 dp[i] [j] 的值最小，显然有`dp[i] [j] = min(dp[i-1] [j-1]，dp[i] [j-1]，dp[[i-1] [j]]) + 1`;

于是，我们的关系式就推出来了了，

3. 步骤三、找出初始值

显然，当 dp[i] [j] 中，如果 i 或者 j 有⼀个为 0，那么还能使用关系式吗？答是不能的，因为这个时候把
i - 1 或者 j - 1，就变成负数了，数组就会出问题了，所以我们的初始值是计算出所有的 dp[0] [0….n] 和
所有的 dp[0….m] [0]。这个还是非常容易计算的，因为当有⼀个字符串的⻓度为 0 时，转化为另外一个
字符串，那就只能⼀直进行插⼊或者删除操作了。