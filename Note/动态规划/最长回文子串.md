## 最长回文子串

回文串是面试常常遇到的问题（虽然问题本身没啥意义），本文就告诉你回文串问题的核心思想是什么。

首先，明确一下什：**回文串就是正着读和反着读都一样的字符串**。

比如说字符串`aba`和`abba`都是回文串，因为它们对称，反过来还是和本身一样。反之，字符串`abac`就不是回文串。

可以看到回文串的的长度可能是奇数，也可能是偶数，这就添加了回文串问题的难度，解决该类问题的核心是**双指针**。下面就通过一道最长回文子串的问题来具体理解一下回文串问题：

![1635298462863](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202110/27/093423-75517.png)

> 注意本题目是求出回文子串，而不是求长度。

```java
string longestPalindrome(string s) {}
```

### 一、思考

对于这个问题，我们首先应该思考的是，给一个字符串`s`，如何在`s`中找到一个回文子串？

有一个很有趣的思路：既然回文串是一个正着反着读都一样的字符串，那么如果我们把`s`反转，称为`s'`，然后在`s`和`s'`中寻找**最长公共子串**，这样应该就能找到最长回文子串。

比如说字符串`abacd`，反过来是`dcaba`，它俩的最长公共子串是`aba`，也就是最长回文子串。

但是这个思路是错误的，比如说字符串`aacxycaa`，反转之后是`aacyxcaa`，最长公共子串是`aac`，但是最长回文子串应该是`aa`。

虽然这个思路不正确，但是**这种把问题转化为其他形式的思考方式是非常值得提倡的**。

下面，就来说一下正确的思路，如何使用双指针。

**寻找回文串的问题核心思想是：从中间开始向两边扩散来判断回文串**。对于最长回文子串，就是这个意思：

```java
for 0 <= i < len(s):
    找到以 s[i] 为中心的回文串
    更新答案
```

但是呢，我们刚才也说了，回文串的长度可能是奇数也可能是偶数，如果是`abba`这种情况，没有一个中心字符，上面的算法就没辙了。所以我们可以修改一下：

![1635298907683](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202110/27/094148-855519.png)

```java
for 0 <= i < len(s):
    找到以 s[i] 为中心的回文串
    找到以 s[i] 和 s[i+1] 为中心的回文串
    更新答案
```

- 如果传入重合的索引编码，进行中心扩散，此时得到的回文子串的长度是奇数；
- 如果传入相邻的索引编码，进行中心扩散，此时得到的回文子串的长度是偶数。

PS：读者可能发现这里的索引会越界，等会会处理。

### 二、代码实现

按照上面的思路，先要实现一个函数来寻找最长回文串，这个函数是有点技巧的：

~~~ java
String palinDrome(String s,int l,int r){
        // 从中间的字符向两边扩展
        while(l >= 0 && r < s.length() ){
            if(s.charAt(l) == s.charAt(r)){
                l--;
                r++;
            }else{
                break;
            }
            
        }
        return s.substring(l+1,r);
    }
~~~

为什么要传入两个指针`l`和`r`呢？**因为这样实现可以同时处理回文串长度为奇数和偶数的情况**：

```java
for 0 <= i < len(s):
    # 找到以 s[i] 为中心的回文串
    palindrome(s, i, i)
    # 找到以 s[i] 和 s[i+1] 为中心的回文串
    palindrome(s, i, i + 1)
    更新答案
```

下面看下`longestPalindrome`的完整代码：

~~~ java
class Solution {
    public String longestPalindrome(String s) {

        String res="";
        for(int i=0;i<s.length();i++){
            String s1=palinDrome(s, i, i);
            String s2=palinDrome(s, i, i+1);
            res = res.length()> s1.length()? res:s1;
            res= res.length()>s2.length()? res:s2;
        }

        return res;

    }

    // 使用双指针法
    String palinDrome(String s,int l,int r){
        // 从中间的字符向两边扩展
        while(l >= 0 && r < s.length() ){
            if(s.charAt(l) == s.charAt(r)){
                l--;
                r++;
            }else{
                break;
            }
            
        }
        return s.substring(l+1,r);
    }
}
~~~

至此，这道最长回文子串的问题就解决了，时间复杂度 O(N^2)，空间复杂度 O(1)。

值得一提的是，这个问题可以用动态规划方法解决，时间复杂度一样，但是空间复杂度至少要 O(N^2) 来存储 DP table。这道题是少有的动态规划非最优解法的问题。

另外，这个问题还有一个巧妙的解法，时间复杂度只需要 O(N)，不过该解法比较复杂，我个人认为没必要掌握。该算法的名字叫 Manacher's Algorithm（马拉车算法），有兴趣的读者可以自行搜索一下。

### 二维动态规划方法 

相比双指针法而言， 二维数组上的动态规划方法的思路更直白。

回文串两边加上两个相同字符，会形成一个新的回文串 。

![1635299549008](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202110/27/095229-44493.png)

方法是，建立二维数组 `dp` ，找出所有的回文子串。

`dp[i][j]` 记录子串 `i..j` 是否为回文串 。

![1635299590282](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202110/27/095311-349115.png)

首先，单个字符就形成一个回文串，所以，所有 `dp[i][i] = true` 。

![1635299608550](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202110/27/095329-657252.png)

然后，容易得到递推关系：

如果字符 `s[i]` 和 `s[j]` 相等，并且子串 `i+1..j-1` 是回文串的话，子串 `i..j` 也是回文串。

也就是，如果 `s[i] == s[j]` 且 `dp[i+1][j-1] = true` 时，`dp[i][j] = true` 。

![1635299654915](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202110/27/095415-768430.png)

这是本方法中主要的递推关系。

不过仍要注意边界情况，即 子串 `i+1..j-1` 的有效性 ，当 `i+1 <= j-1` 时，它才有效。

反之，如果不满足，此时 `j <= i+1` ，也就是子串 `i..j` 最多有两个字符， 如果两个字符 `s[i]` 和 `s[j]` 相等，那么是回文串。

至此，递推关系已经分析完。

最后，考虑到 主要的递推关系 是由已知子串 `i+1..j-1` 的情况， 递推到 `i..j` 的情况， 因此，迭代过程需要反序迭代变量 `i` ，正序迭代 `j` 。

此外，可以通过一个表格，来理解整个 `dp` 数组的规划过程。

![1635299712740](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202110/27/095513-250095.png)

上面的表格填表过程：

1. 初始化所有方格写 `false` 。
2. 填写对角线写 `true` 。
3. 自对角线右下角开始，自下而上、自左而右，按箭头方向根据递推关系填表。

最后，找到所有回文子串后，即可找到最长回文子串和其长度

**代码实现**

~~~ java

~~~

