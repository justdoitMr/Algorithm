# 动态规划问题优化

## O(n*m) 空间复杂度优化成 O(n)

青蛙跳台阶问题，声明了一个长度为N的数组，所以空间复杂度是O(n),针对优化可以使用迭代法，这样空间复杂度就可以降低到o(1)复杂度。

## 案例例1：最多路路径数

**问题描述**

> ⼀一个机器⼈位于⼀个 m x n 网格的左上⻆角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器⼈试图达到网格的右下角（在下图中标记为“Finish”）。问总共有多少条不同的路路径？

![1635141383806](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202110/25/135624-857383.png)

常规解法：

~~~ java
class Solution {
    public int uniquePaths(int m, int n) {
        if(m <= 0 || n<= 0)
        return -1;

        // 使用动态规划方法
        // 1、定义状态数组
        int [][]status=new int[m][n];
        // 2、初始化边界条件,第一行和第一列全部初始化为1，因为只有一种走法
        for(int i=0;i<m;i++){
            status[i][0]=1;
        }
        for(int j=0;j<n;j++){
            status[0][j]=1;
        }
        // 3、定义状态方程
        // d[i][j]=d[i-1][j]+d[i][j-1]
        for(int i=1;i<m;i++){
            for(int j=1;j<n;j++){
                status[i][j]=status[i-1][j]+status[i][j-1];
            }
        }
        return status[m-1][n-1];
    }
}
~~~

这种做法的空间复杂度是 O(n * m)，下面我们来讲解如何优化成 O(n)。

dp[i] [j] 是一个二维矩阵，我们来画个二维矩阵的图，对矩阵进行初始化:

![1635141510764](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202110/25/135831-658852.png)

然后根据公式 `dp[i][j] = dp[i-1][j] + dp[i][j-1] `来填充矩阵的其他值。下面我们先填充第⼆二行的值。

![1635141599317](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202110/25/140000-210512.png)

大家想一个问题，当我们要填充第三行的值的时候，我们需要⽤到第一行的值吗？答是不需要的，不行
你试试，当你要填充第三，第四....第 n 行的时候，第一行的值永远不会用到，只要填充第二行的值时会
用到。

根据公式 `dp[i][j] = dp[i-1][j] + dp[i][j-1]`，我们可以知道，当我们要计算第 i 行的值时，除了会⽤到第 `i -1 `行外，其他第 1 至 第 i-2 行的值我们都是不需要用到的，也就是说，对于那部分⽤不到的值我们还有必要保存他们吗？

答是没必要，我们只需要用⼀个⼀维的 dp[] 来保存一行的历史记录就可以了。然后在计算机的过程中，不不断着更新 dp[] 的值。单说估计你可能不好理解，下⾯我就⼿把⼿来演示下这个过程。

1. 刚开始初始化第一⾏，此时 dp[0..n-1] 的值就是第⼀行的值。

![1635141873600](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202110/25/140434-267862.png)

2. 接着我们来一边填充第⼆行的值一边更新 dp[i] 的值，⼀边把第一行的值抛弃掉。

> 为了⽅便描述，下面我们用arr (i，j）表示矩阵中第 i 行 第 j 列的值。从 0 开始哈，就是说有第 0
> ⾏

显然，矩阵(1, 0) 的值相当于以往的初始化值，为 1。然后这个时候矩阵 (0，0）的值不在需要保存了，因为再也⽤不到了。

![1635141983155](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202110/25/140624-633188.png)

这个时候，我们也要跟着更新 dp[0] 的值了了，刚开始 dp[0] = (0, 0)，现在更新为 dp[0] = (1, 0)。

接着继续更新 (1, 1) 的值，根据之前的公式 `（i, j) = (i-1, j) + (i, j- 1)`。即 `（1，1）=（0，1）+（1，0）=2`。

![1635142178502](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202110/25/140939-252426.png)

大家看图，以往的⼆维的时候，` dp[i][j] = dp[i-1] [j]+ dp[i][j-1]`。现在转化成一维，不就是 `dp[i] = dp[i]+dp[i-1] `吗？即 `dp[1] = dp[1] + dp[0]`，而且还动态帮我们更新了了 dp[1] 的值。因为刚开始 dp[i] 的保存第一行的值的，现在更新为保存第二行的值。

![1635142292252](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202110/25/141132-461836.png)

同样的道理，按照这样的模式一直来计算第二行的值，顺便把第一行的值抛弃掉，结果如下

![1635142332753](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202110/25/141213-901048.png)

此时，dp[i] 将完全保存着第二行的值，并且我们可以推导出公式`dp[i] = dp[i-1] + dp[i]`

> `dp[i-1] `相当于之前的` dp[i-1][j]`，`dp[i] `相当于之前的` dp[i][j-1]`。

![1635142395989](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202110/25/141317-407413.png)