## 二叉树所有路径

**题目描述**

![1635941519656](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202111/03/201201-595553.png)

### 递归法（深度优先搜索）

深度优先搜索就是从根节点开始，一直往左子节点走，直到左子节点为空，让后返回到上一步从右子节点在执行同样的操作，就像下面图中这样

![1635941793535](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202111/03/201634-742485.png)

**二叉树深度优先遍历代码**

~~~ java
 public static void treeDFS(TreeNode root) {
        //当前节点为空直接返回
        if (root == null)
            return;
        //打印当前节点的值
        System.out.println(root.val);
        //然后递归遍历左右子节点
        treeDFS(root.left);
        treeDFS(root.right);
    }
~~~

我们完全可以仿照上面的代码来写，不同的是每个节点访问的时候不是把他打印出来，而是先把他存储起来，到叶子结点的时候再添加到集合中，最后返回集合的值:

~~~ java
class Solution {
    List<String> res=new ArrayList<>();
    StringBuilder str=new StringBuilder();
    public List<String> binaryTreePaths(TreeNode root) {

        if(root == null){
            return res;
        }
        getbinaryTreePaths(root,"");
        return res;
    }
    void getbinaryTreePaths(TreeNode root,String path){
        
        if(root == null){
            return;
        }
        // str.append(root.val);
        if(root.left == null && root.right == null){
            res.add(path+String.valueOf(root.val).toString());
            return;
        }
        getbinaryTreePaths(root.left,path+root.val+"->");
        getbinaryTreePaths(root.right,path+root.val+"->");
    }
}
~~~

