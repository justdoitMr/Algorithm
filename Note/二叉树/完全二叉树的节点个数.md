## 完全二叉树的节点个数

**题目描述**

![1635936572933](C:\Users\MrR\AppData\Roaming\Typora\typora-user-images\1635936572933.png)

**思路一**

题目告知是完全二叉树，那么假如是满二叉树，那么总的节点数可以直接计算出来，时间复杂度是logn级别的，如果是完全二叉树，那么总有一部分子树是满二叉树，所以递归的思路先判断是否是满二叉树，是满二叉树的话直接计算节点个数，时间复杂度是树的高度，但是如果不是满二叉树的话，满二叉树的时间复杂度是logn级别，也就是树的高度，而递归是常数级别。所以总体还是logn级别的复杂度。

**完整代码**

~~~ java
class Solution {
    public int countNodes(TreeNode root) {
        // 完全二叉树介于普通二叉树和满二叉树之间
        TreeNode left=root;
        TreeNode right=root;
        int l=0;
        int r=0;
        // 先计算左右子树的高度
        while(left != null){
            left=left.left;
            l++;
        }

        while(right != null){
            right=right.right;
            r++;
        }
        // 如果l==r，那么就说明是满二叉树
        if(l == r){
            return (int)Math.pow(2, l)-1;
        }
        // 否则说明是完全二叉树
        return 1+countNodes(root.left)+countNodes(root.right);

    }
}
~~~

**思路二**

普通递归的方法,求总的节点个数，就需要知道每一个子树的节点个数，所以分别对左右子树进行递归。

~~~ java
class Solution {
    public int countNodes(TreeNode root) {
        return ComputeCountNode(root);

    }

    // 普通递归
    int ComputeCountNode(TreeNode root){
        
        if(root == null){
            return 0;
        }
        int leftNum=ComputeCountNode(root.left);
        int rightNum= ComputeCountNode(root.right);

        return leftNum+rightNum+1;
    }
}
~~~

时间内复杂度：递归程序的时间复杂度是节点的个数*每一次递归的时间复杂度，递归树的节点个数在2的n次方级别，二每一次递归时间复杂度是常数级别，所以总的在2的n次方级别。