# 动态规划问题状态转移方程小结

## 跳台阶问题

> 定义d[i]数组为到第i个台阶位置，一共右多少种跳法。

假设当前在第n个位置，那么如果跳到第n个位置，一共有多少种跳法。

- 第一种是从n-1位置跳
- 第二种是从n-2位置跳

所以跳到第n个台阶共有两种方法，也就是`d[n]=d[n-1+d[n-2]`

> 所以状态转移方程是：`d[n]=d[n-1+d[n-2]`

## 机器人问题

> 定义`d[i][j]`为到第`[i,j]`位置时候，右多少条路径

假设机器人现在在d[i,j]位置，但是机器人每一次只可以向下或者向右走，所以走到`d[i][j]`位置也有两种方法：

- 从`d[i][j-1]`位置
- 从`d[i-1][j]`位置

> 所以找到的状态转移方程是：`d[i][j]=d[i][j-1]+d[i-1][j]`

## 对角和问题

> 定义`d[i][j]`为到第`[i,j]`位置时候，最短路径和是多少

因为是求最小值，那么假设现在在`d[i,j]`位置，但是机器人每一次只可以向下或者向右走，所以走到`d[i][j]`位置也有两种方法：

- 从`d[i][j-1]`位置
- 从`d[i-1][j]`位置

> 因为是求路径的最小值，所以我们取两个位置的最小值，可以得到状态转移方程是：
>
> `d[i][j]=min(d[i][j-1]+d[i-1][j])+dp[i][j]`

## 最大子序列和

> 以nums[i]为结尾的「最大子数组和」为dp[i]。

那么还是使用数学归纳法，假设我们现在知道`dp[i-1]`，那么我们如何知道`dp[i]`呢，显然，我们在这里右两种选择：

- 要么把num[i]和前面子序列和链接在一起组成一个更大的子序列和。
- 要么把num[i]单独放在一起开始计算一个新的子序列和.

> 根据归纳总结，我们可以得到状态转移方程：`dp[i]=max(dp[i-1]+num[i]，num[i])`

## 最长递增子序列

> 定义dp[i] 表示以 nums[i] 这个数结尾的最长递增子序列的长度

那么还是数学归纳法，假设现在`dp[0],dp[1]dp[2]…….dp[i-1]`我们都已经计算出来，那么此时我们如何通过`dp[i-1]`计算处`dp[i]`呢。很明显，这道题目是非连续的，所以我们只需要找到，在dp[i]之前的并且数组值小于num[i]的最大的那个dp对应的值，当然我们可能找到多个满足条件的结果，但是我们只取最大的，所以我们可以得到状态转移方程为：

> `dp[i]= Math.max(dp[i], dp[j] + 1)`，这里要注意一点，num[j] < num[i]时候才成立，j<i

## 最长连续递增子序列

> 还是先定义我们dp数组的含义：dp[i]：以下标i为结尾的数组的连续递增的子序列长度为dp[i]。

先假设我们的`dp[0],dp[1]dp[2]…….dp[i-1]`已经求出，那么如何取推导`dp[i]`的值呢？本题目求的是连续的子序列，所以求`dp[i]`也有两种情况：

- 要么把`num[i]`添加到前面的连续子序列当中，形成一个更大的子序列
- 要么把`num[i]`单独形成一个子序列

> 所以我们可以得到状态转移方程：`dp[i]=max(dp[i-1]+1，1)`